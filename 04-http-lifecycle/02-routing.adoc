---
permalink: routing
title: 路由
category: HTTP生命周期
---
= Routing

toc::[]

AdonisJs路由热衷 *REST约定* ，但仍然有足够的空间来创建和注册自定义路由。在本指南中，我们学习如何创建路由，绑定控制器方法以及用不同的方式来组织它们。

所有的应用程序路径都在 `start/routes.js` 文件中注册。另外，你可以自由创建多个路由文件，只需要在 `routes.js` 文件中引用它们。

== 基本例子
最基本的路由需要执行URL路径和闭包。闭包的返回值作为响应发回。

[source, js]
----
Route.get('/', () => 'Hello world')
----

使用`adonis serve --dev`启动服务器后，如果您访问 link:http://localhost:3333[localhost:3333]，您会在浏览器中看到 *Hello world* 。

== 路由方法/动词
Restful路由使用不同的HTTP方法来指示请求的类型。例如： `POST` 方法用于创建记录， `GET` 用于获取记录。

您可以使用以下方法为不同的HTTP方法定义路由。

==== get
使用GET方法创建路由。

[source, js]
----
Route.get('/', async () => {
})
----

==== post
使用POST方法创建路由。

[source, js]
----
Route.post('/', async () => {
})
----

==== put/patch
`PUT` 和 `PATCH` 方法用于更新资源。

[source, js]
----
Route.put('/', async () => {
})

Route.patch('/', async () => {
})
----

==== delete
`DELETE` 方法表示删除资源。

[source, js]
----
Route.delete('/', async () => {
})
----

==== route
另外，您可以使用 `Route.route` 方法创建响应多个动词的路由。

[source, js]
----
Route.route('/', async () => {

}, ['GET', 'POST'])
----

== 路由参数
使用静态路径创建路由并不是很有用，而且通常需要一种方法来接受动态数据作为URL的一部分，例如：

[source, bash]
----
/posts/1
/posts/2
/posts/300
----

您需要一种方法从URL中获取帖子ID并呈现相应的帖子。通过定义路由参数也是一样。

[source, js]
----
Route.get('posts/:id', async ({ params }) => {
  const post = await Post.find(params.id)
  return post
})
----

`:id` 是作为 `params` 对象的一部分传递的路由参数。另外，你可以通过在参数中加入 `?` 使其成为可选的。例如：

[source, js]
----
Route.get('make/:drink?', async ({ params }) => {
  // 当:drink未定义时，使用Coffee作为默认值
  const drink = params.drink || 'Coffee'

  return `Will make ${drink} for you`
})
----

== SPA的路由
通常你会发现自己创建了一个SPA（单页面应用程序），在那里你想要从服务器渲染一个单一的视图，并使用你最喜欢的前端框架处理前端的路由。

这可以通过定义通配符路由来完成。

[source, js]
----
Route.any('*', ({ view }) => view.render('main'))
----

如果您有任何其他特定路由，则应在通配符路由之前对其进行定义。例如：

[source, js]
----
Route.get('/api/v1/users', 'UserController.index')

// 通配符路由
Route.any('*', ({ view }) => view.render('main'))
----

== 绑定控制器
将所有代码写入单个文件不太合理，也不实用，因为将匿名函数定义为路由动作扩展性较差。

AdonisJs是一个MVC框架，它提供了一个名为 *Controllers* 的抽象层，用于将所有请求处理逻辑放在一个自定义ES6类中。

我们使用 `make:controller` 命令创建一个控制器。
[source, bash]
----
adonis make:controller Posts
----

.Output
[source, bash]
----
✔ create  app/Controllers/Http/PostController.js
----

下一步是将控制器方法绑定到路由。它被定义为一个 `点（.）` 分隔的字符串。

[source, js]
----
Route.get('posts', 'PostController.index')
----
最后，我们需要在控制器类上创建 `index` 方法。

[source, js]
----
'use strict'

class PostController {
  index () {
    return 'Hello world'
  }
}

module.exports = PostController
----

== 路由中间件
您可以通过调用“middleware”方法将选定的中间件应用于路由。

[source, js]
----
Route
  .get('profile', 'UserController.profile')
  .middleware(['auth'])
----

`middleware` 方法接受一个已命名的中间件数组，它在 `start/kernel.js` 文件中定义。

.start/kernel.js
[source, js]
----
const namedMiddleware = {
  auth: 'Adonis/Middleware/Auth'
}
----

点击 link:middleware[这里] 了解更多关于中间件的信息。

== 命名路线
路径是在 `start/routes.js` 文件中定义的，但在应用程序中的任何地方都可以引用。例如：定义表单操作以提交给特定的URL。

[source, js]
----
Route.post('users', 'UserController.store')
----

在模板中

[source, edge]
----
<form method="POST" action="/users">
</form>
----

现在，如果您将路由路径从 `/users` 更改为其他路径，则必须记得回来并在模板内改变它。

为了克服这个问题，你可以唯一地命名你的路由并在程序的其他部分引用它们。

[source, js]
----
Route
  .post('users', 'UserController.store')
  .as('storeUser')
----

`as` 方法给你的路线命名。现在在您的模板中，您可以使用视图全局引用它。

[source, edge]
----
<form method="POST" action="{{ route('storeUser') }}">
</form>
----

== 路线格式
路由格式为 link:https://en.wikipedia.org/wiki/Content_negotiation[内容协商, window="_blank"] 打开了一条新途径，您可以在其中定义接受响应格式作为URL的一部分。

路径格式是客户端和服务器之间的一种契约，其中要创建的响应类型。例如：

[source, js]
----
Route
  .get('users', async ({ request, view }) => {
    const users = await User.all()

    if (request.format() === 'json') {
      return users
    } else {
      return view.render('users.list', { users })
    }

  })
  .formats(['json'])
----

现在， `users` 可以根据URL以多种格式进行响应。

/users.json::
以JSON形式返回用户数组。

/users::
渲染视图并返回HTML

此外，您可以禁用默认URL并始终强制客户端定义格式。

[source, js]
----
Route
  .get('/', async ({ request, view }) => {
    const users = await User.all()
    const format = request.format()

    switch (format) {
      case 'html':
        return view.render('users.list', { users })
      case 'json':
        return users
    }
  })
  .formats(['json', 'html'], true)
----

传递 `true` 作为第二个参数可以确保客户端定义了一种预期的格式。否则，会抛出404错误。

== 资源路由
如果您喜欢围绕REST约定构建Web应用程序，那么 *资源路由* 可以通过编写更少的代码来帮助您定义传统路由。

NOTE: 需要将 *Controller* 绑定到资源。绑定一个闭包会抛出一个异常。

[source, js]
----
Route.resource('users', 'UsersController')
----

默认的 `Route.resource` 方法会创建7条路由

[role="resource-table", options="header", cols="40%, 10%, 25%, 25%"]
|===
| Url | 动词  | 名称 | 控制器方法
| users [description]#显示所有用户# | GET | users.index | `UsersController.index`
| users/create [description]#渲染一个用于创建用户的表单# | GET  | users.create | `UsersController.create`
| users [description]#新建/保存一个新用户# | POST | users.store | `UsersController.store`
| users/:id [description]#显示一个用户# | GET | users.show | `UsersController.show`.
| users/:id/edit [description]#渲染一个用于更新用户的表单# | GET | users.edit | `UsersController.edit`
| users/:id [description]#更新用户的详情。# | PUT or PATCH | users.update | `UsersController.update`
| users/:id [description]#通过ID删除一个用户# | DELETE | users.destroy | `UsersController.destroy`
|===

嵌套资源可以使用 `点（.）` 表示法创建。

[source, js]
----
Route.resource('posts.comments', 'CommentsController')
----

=== 过滤资源
您可以通过链接少数方法来限制资源应该创建的路由数量。

==== apiOnly
通过删除 `users/create` and `users/:id/edit` 路由来限制仅创建5条路由。由于在编写API服务器时，您可能想要在API客户端内呈现表单（例如，移动应用程序，前端Web框架等）。

[source, js]
----
Route
  .resource('users', 'UsersController')
  .apiOnly()
----

==== only([名称])
删除所有其他路由，仅保留传递给 `only` 方法的路由。

[source, js]
----
Route
  .resource('users', 'UsersController')
  .only(['index', 'show'])
----

==== except([名称])
删除传递给 `except` 方法的名称的路由。

[source, js]
----
Route
  .resource('users', 'UsersController')
  .except(['index', 'show'])
----

=== 资源中间件
您可以像您对单个路由所做的一样将中间件附加到资源。

[source, js]
----
Route
  .resource('users', 'UsersController')
  .middleware(['auth'])
----

由于将auth中间件附加到所有路由并不总是需要，因此可以通过传递值映射来自定义行为。

[source, js]
----
Route
  .resource('users', 'UsersController')
  .middleware(new Map([
    [['store', 'update', 'destroy'], ['auth']]
  ]))
----

这里我们定义了 *store*，*update* 和 *destroy* 控制器方法中的 `auth` 中间件。

=== 资源格式
此外，您可以为所有的资源路由定义格式，就像为单个路线或一组路线做的那样。

[source, js]
----
Route
  .resource('users', 'UsersController')
  .formats(['json'])
----

== 路由域名
AdonisJs使得在单个代码库中为多个域提供服务变得非常简单。这些域可以是像 `blog.adonisjs.com` 这样的静态端点或像 `:user.adonisjs.com` 这样的动态端点。

TIP: 您也可以在单个路由上定义域，但将域专用路由分组是个好主意。

[source, js]
----
Route
  .group(() => {
    Route.get('users', async ({ subdomains }) => {
      return `The username is ${subdomains.user}`
    })
  })
  .domain(':user.myapp.com')
----

现在，如果你访问 `virk.myapp.com` ，你会看到上面的路由被执行。

== 路由组
很多时候，你的应用程序路线共享共同的逻辑/配置。因此，不要在每条路线上重新定义配置，最好将它们分组。例如：

不需要
[source, js]
----
Route.get('api/v1/users', 'UserController.index')
Route.post('api/v1/users', 'UserController.store')
----

相反，我们可以在这里使用路线的组。

[source, js]
----
Route
  .group(() => {
    Route.get('users', 'UserController.index')
    Route.post('users', 'UserController.store')
  })
  .prefix('api/v1')
----

就像 `prefix` 方法一样，您可以在一组路由上调用以下方法。

==== 中间件
在一组路由上定义中间件。所有组中间件都是在单个路由上定义的中间件之前执行的。

[source, js]
----
Route
  .group(() => {
  })
  .middleware(['auth'])
----

==== 命名空间
通常我们有多个控制器分组在同一个文件夹内。通过 `namespace` 方法，您可以指定组中的文件夹。例如，使用以下文件夹结构：

[source, bash]
----
├── app
│   └── Controller
│       └── Http
|           └──Api
|              └── v1
|                  ├── UserController.js
|                  └── RoleController.js
----

通常你会定义资源如下：

[source, js]
----
Route.
  group(() => {
    Route.resource('/users', 'Api/v1/UserController')
    Route.resource('/roles', 'Api/v1/RoleController')
  })
  .prefix('api/v1')
----

使用 `namespace` 方法，你可以简化这个组：

[source, js]
----
Route
  .group(() => {
    Route.resource('/users', 'UserController')
    Route.resource('/roles', 'RoleController')
  })
  .prefix('api/v1')
  .namespace('Api/v1')
----

==== domain
指定一组路由上的路由。

[source, js]
----
Route
  .group(() => {
  })
  .domain('blog.adonisjs.com')
----

==== formats
定义一组路由上的格式。

[source, js]
----
Route
  .group(() => {
  })
  .formats(['json', 'html'])
----

== 路由渲染器
路由渲染器可以直接渲染视图而不需要创建控制器方法或绑定闭包。

为了取代下面的代码

[source, js]
----
Route.get('/', async function ({ view }) {
  return view.render('welcome')
})
----

我们可以这样写

[source, js]
----
Route.on('/').render('welcome')
----

## 扩展路由
AdonisJs可以通过将自定义的方法添加到 *macros* 来扩展路由。

NOTE: 由于扩展路由的代码需要执行一次，因此可以使用提供程序或触发器挂钩。请务必在继续之前阅读 link:[如何扩展]。

[source, js]
----
const Route = use('Route')
const Server = use('Server')

// 中间件函数
async function bindMiddleware (ctx, next, [model, identifier, key]) {
  const identifierValue = ctx.params[identifier]

  if (identifierValue) {
    ctx[key] = await use(model).findBy(identifier, identifierValue)
  }

  await next()
}

// 使用名字预先注册中间件
Server.registerNamed({ bm: bindMiddleware })

// 添加宏
Route.Route.macro('bind', function (model, identifier, key) {
  this.middleware(`bm:${model},${identifier},${key}`)
  return this
})
----

`bind` 方法可以如下使用。

[source, js]
----
Route
  .get('user/:id', ({ user }) => {
    return user
  })
  .bind('App/Models/User', 'id', 'user')
----

在这里，我们将`bind`方法添加到 link:https://github.com/adonisjs/adonis-framework/blob/develop/src/Route/index.js[Route 类] 原型。 此方法在内部向路由添加中间件，该中间件使用模型从数据库中提取记录。

您也可以将宏添加到以下类中。

[ol-shrinked]
1. link:https://github.com/adonisjs/adonis-framework/blob/develop/src/Route/Group.js[RouteGroup]
2. link:https://github.com/adonisjs/adonis-framework/blob/develop/src/Route/Resource.js[RouteResource]
3. link:https://github.com/adonisjs/adonis-framework/blob/develop/src/Route/Brisk.js[BriskRoute]

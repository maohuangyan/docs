---
permalink: request
title: 请求
category: HTTP生命周期
---
= Request

toc::[]

本指南概述了如何使用HTTP link:https://github.com/adonisjs/adonis-framework/blob/develop/src/Request/index.js[Request, window="_blank"] 对象读取请求的数据。

TIP: Node.js原始 `req` 对象可以作为 `request.request` 访问。

AdonisJs传递当前HTTP请求对象作为 link:http-context#_http_context[上下文] 的一部分，它发送给所有路由处理程序和中间件。

[source, js]
----
Route.get('/', ({ request }) => {
})
----

我们使用 link:https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment[ES6解构, window="_blank"] 从上下文获取 `request` 对象。

== 请求体
请求对象提供了一堆有用的方法来读取请求主体。首先，确保你已经安装了body-parser中间件。
如果没有，请按照下面的步骤操作。

=== 设置bodyparser
NOTE: 仅Fullstack和API的模板附带预配置的body-parser。

[source, js]
----
adonis install @adonisjs/bodyparser
----

然后在 `start/app.js` 文件中注册提供者
[source, js]
----
const providers = [
  '@adonisjs/bodyparser/providers/BodyParserProvider'
]
----

另外，在 `start/kernel.js` 文件中注册全局中间件。
[source, js]
----
const globalMiddleware = [
  'Adonis/Middleware/BodyParser'
]
----

=== 方法
以下是您可以调用以读取请求正文的方法列表。

==== all
将请求主体作为对象返回。这个方法将 `查询参数` 和 `请求体` 合并在一起。

[source, js]
----
const all = request.all()
----

==== get
获取查询参数的对象

[source, js]
----
const query = request.get()
----

==== post
获取请求正文的对象

[source, js]
----
const body = request.post()
----

==== raw
获取提交的原始数据。

NOTE: 如果原始数据是带有 `Content-type：application/json` 的JSON，那么bodyparser会巧妙地解析它，并将它作为 `post` 方法的一部分返回。

[source, js]
----
const body = request.raw()
----

==== only
使用 `only` 返回包含指定键的一个对象

[source, js]
----
const body = request.only(['username', 'email', 'age'])
----

==== except
与 `only` 相反，并返回除了定义的键之外的所有内容。

[source, js]
----
const body = request.except(['csrf_token', 'submit'])
----

==== input
仅为给定键获取值，如果不存在，则返回 `默认` 值。

[source, js]
----
const drink = request.input('drink')

// 使用默认值
const drink = request.input('drink', 'coffee')
----


== 请求集合
通常你想处理通过键/值对提交数据数组的HTML表单。 *例如：* 一次创建多个用户的表单。

[source, html]
----
<form method="POST" action="/users">
  <input type="text" name="username[0]" />
  <input type="text" name="age[0]" />

  <hr>
  <input type="text" name="username[1]" />
  <input type="text" name="age[1]" />
</form>
----

假设我们想要在控制器中获取用户名和年龄。

[source, js]
----
const users = request.only(['username', 'age'])

// output
{ username: ['virk', 'nikk'], age: [26, 25] }
----

上面的数据是你无法直接保存到数据库的东西，因为它的格式不正确。

使用 `request.collect` ，我们可以将其格式化为开箱即用的格式。

[source, js]
----
const users = request.collect(['username', 'age'])

// 输出
[{ username: 'virk', age: 26 }, { username: 'nikk', age: 25 }]

// 保存到数据库
await User.createMany(users)
----

== 请求头
此外，您可以使用以下方法之一从请求中读取请求头。

==== header
给定键的请求头。

[source, js]
----
const auth = request.header('authorization')

// 不同的单词大小写
const auth = request.header('Authorization')
----

==== headers
返回请求头的对象。

[source, js]
----
const headers = request.headers()
----

== Cookies
使用以下方法之一读取Cookies

==== cookie
返回cookie中某个键的值。默认返回可选的默认值。

[source, js]
----
const cartTotal = request.cookie('cart_total')

// 使用默认值
const cartTotal = request.cookie('cart_total', 0)
----

==== cookies
返回所有cookies的对象

[source, js]
----
const cookies = request.cookies()
----

您也可以使用以下方法来读取客户端上设置的Cookie。

==== plainCookie
[source, js]
----
const jsCookie = request.plainCookie('cart_total')
----

==== plainCookies
获取原始Cookie的对象
[source, js]
----
const plainCookies = request.plainCookies()
----

== 内容协商
link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation[内容协商, window="_blank"] 是服务器和客户端决定要返回的最佳响应类型的一种方式从服务器。

由于Web服务器不仅提供网页，他们还必须响应API的 *JSON* 或者 *XML* 请求。消费者可以要求服务器以特定格式返回响应，而不是为每种内容类型创建单独的URL。

现在要以特定的格式构建响应，服务器需要首先知道它。使用 `accept` 方法可以做到这一点。
==== accepts
读取“Accept”请求头以了解响应格式。

[source, js]
----
const bestFormat = request.accepts(['json', 'html'])

if (bestFormat === 'json') {
  return response.json(users)
}

return view.render('users.list', { users })
----

==== language
语言也可以基于 `Accept-Language` 头部进行协商。

[source, js]
----
const language = request.language(['en', 'fr'])
----

== 请求对象的方法
以下是所有请求对象的方法及其使用示例的列表

==== url
返回当前的请求url

[source, js]
----
const url = request.url()
----

==== originalUrl
带有查询字符串的网址

[source, js]
----
const url = request.originalUrl()
----

==== method
返回请求HTTP方法。

[source, js]
----
const method = request.method()
----

==== intended
由于Adonisjs允许 xref:_method_spoofing[方法欺骗]，因此可以使用 `intended` 方法获取实际的方法。

[source, js]
----
const method = request.intended()
----

==== ip
为返回用户最可信的IP地址。

[source, js]
----
const ip = request.ip()
----

==== ips
返回从大多数到最不受信任的ips数组。它删除默认可以通过 `ip` 方法访问的ip地址，。

[source, js]
----
const ips = request.ips()
----

==== subdomains
返回请求子域列表，此方法从列表中移除 `www`。

[source, js]
----
const subdomains = request.subdomains()
----

==== ajax
检查 `X-Requested-With` 头以确定请求是否为ajax。

[source, js]
----
if (request.ajax()) {
  // 做点什么
}
----

==== pjax
link:https://github.com/defunkt/jquery-pjax[Pjax, window="_blank"] 是利用Ajax在传统应用程序上提供更好用户体验的一种演进方式。在Rails世界，它被称为Turbolinks。

此方法查看 `X-PJAX` 头以确定请求是否为pjax。
[source, js]
----
if (request.pjax()) {
  // 做点什么
}
----

==== hostname
返回请求主机名

[source, js]
----
const hostname = request.hostname()
----

==== protocol
返回请求协议。

[source, js]
----
const protocol = request.protocol()
----

==== match
匹配当前请求URL的一组表达式以判断它是否匹配。

[source, js]
----
// 当前请求地址 - posts/1

request.match(['posts/:id']) // returns true
----

==== hasBody
指示请求是否具有请求体的布尔值。它主要用于bodyparser知道是否解析请求体。

[source, js]
----
if (request.hasBody()) {
  // 做点什么
}
----

==== is
`is` 方法为当前请求返回最匹配的内容类型。该检查完全基于 `content-type` 标题。

[source, js]
----
// 假设 content-type 是 `application/json`

request.is(['json', 'html']) // returns - json

request.is(['application/*']) // returns - application/json
----

== 方法欺骗
HTML表单只能发起 `GET` 和 `POST` 请求​​，这意味着你不能使用其他HTTP方法（如 *PUT*， *DELETE* 等）的REST约定。

AdonisJs使得它更简单地绕过请求方法作为查询字符串的一部分，然后它会自动为您执行正确的路由。

[source, js]
----
Route.put('users', 'UserController.update')
----

[source, html]
----
<form method="POST" action="/users?_method=PUT">
----

该功能在满足以下条件时可用。

1. 原始请求方法是 `POST` 。
2. `config/app.js` 文件中启用 `allowMethodSpoofing`。


== 扩展 Request

通常你需要通过附加新方法来扩展 `Request` 原型。 通过在Request类上定义一个宏也可以做到这一点。

NOTE: 由于扩展 `Request` 的代码需要执行一次，因此可以使用提供者或点火器挂钩。 请务必在继续之前阅读 link:[如何扩展]。

[source, javascript]
----
const Request = use('Adonis/Src/Request')

Request.macro('cartValue', function () {
  return this.cookie('cartValue', 0)
})
----
